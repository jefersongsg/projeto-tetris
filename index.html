<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <link rel="icon" href="/tetris_app_regular_icon_203201.ico">
    <title>Block Box</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!--<h1>Block Box </h1> -->
    
    <div class="game-container">
        <canvas id="tetris"></canvas>
        
        <div class="info-panel">
            <div class="score">
                Pontuação: <span id="score">0</span>
            </div>
            
            <div class="next-piece">
                <p>Próxima peça:</p>
                <canvas id="next" width="120" height="120"></canvas>
            </div>
            
            <div class="controls">
                <p>A D : Mover</p>
                <p>W : Rotacionar</p>
                <p>S : Descer</p>
                <p>Espaço : Queda rápida</p>
                <p>Enter : Pausar/Retomar</p>
                <p>R : Reiniciar</p>
            </div>
        </div>
    </div>
    
    <div id="game-over">GAME OVER</div>
   
</body>

     <script>
     // Configuração inicial do jogo
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');
        
        // Definindo tamanho da grade do jogo
        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 30;
        
        // Ajustando tamanho do canvas baseado no tamanho da grade
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        context.scale(BLOCK_SIZE, BLOCK_SIZE);
        
        // Configuração do canvas para próxima peça
        nextCanvas.width = 120;
        nextCanvas.height = 120;
        nextContext.scale(30, 30);
        
        // Matriz que representa o tabuleiro do jogo
        // 0 representa espaço vazio, 1 representa bloco ocupado
        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        
        // Variáveis para controle do jogo
        let gameOver = false;
        let paused = false;
        let score = 0;
        let dropCounter = 0;
        let dropInterval = 1000; // Tempo em ms para peça cair um bloco
        let lastTime = 0;
        
        // Definição das peças (Tetrominós) - todas usam o mesmo valor (1) para marcar blocos
        const PIECES = [
            // Peça I
            {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ]
            },
            // Peça L
            {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ]
            },
            // Peça J
            {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ]
            },
            // Peça O (Quadrado)
            {
                shape: [
                    [1, 1],
                    [1, 1]
                ]
            },
            // Peça Z
            {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ]
            },
            // Peça S
            {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ]
            },
            // Peça T
            {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ]
            }
        ];
        
        // Player representa o estado atual da peça em jogo
        const player = {
            pos: { x: 0, y: 0 },
            piece: null,
            nextPiece: null
        };
        
        // Função principal de loop do jogo
        function update(time = 0) {
            if (paused || gameOver) {
                requestAnimationFrame(update);
                return;
            }
        
            const deltaTime = time - lastTime;
            lastTime = time;
        
            // Incrementa o contador e move a peça para baixo quando necessário
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
                dropCounter = 0;
            }
        
            // Limpa o canvas e desenha o estado atual do jogo
            draw();
        
            // Continua o loop se o jogo não terminou
            requestAnimationFrame(update);
        }
        
        // Função para desenhar o tabuleiro e a peça atual
        function draw() {
            // Limpa o canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
        
            // Desenha a grade de fundo
            drawGrid();
        
            // Desenha o tabuleiro
            drawBoard();
        
            // Desenha a peça atual
            if (player.piece) {
                drawPiece(context, player.piece, player.pos);
            }
        
            // Desenha a próxima peça no canvas de prévia
            drawNextPiece();
        
            // Atualiza a pontuação
            document.getElementById('score').textContent = score;
        
            // Exibir Game Over
            if (gameOver) {
                document.getElementById('game-over').style.display = 'block';
            }
        }
        
        // Função para desenhar a grade de fundo
        function drawGrid() {
            context.strokeStyle = '#cccccc';
            context.lineWidth = 0.02;
        
            // Linhas horizontais
            for (let y = 0; y <= ROWS; y++) {
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(COLS, y);
                context.stroke();
            }
        
            // Linhas verticais
            for (let x = 0; x <= COLS; x++) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, ROWS);
                context.stroke();
            }
        }
        
        // Função para desenhar o tabuleiro
        function drawBoard() {
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // Desenha blocos como quadrados vazios com borda
                        context.strokeStyle = 'white';
                        context.lineWidth = 0.05;
                        context.strokeRect(x, y, 1, 1);
        
                        // Adiciona uma marca X dentro do bloco para diferenciar
                        context.beginPath();
                        context.moveTo(x, y);
                        context.lineTo(x + 1, y + 1);
                        context.moveTo(x + 1, y);
                        context.lineTo(x, y + 1);
                        context.stroke();
                    }
                });
            });
        }
        
        // Função para desenhar uma peça
        function drawPiece(ctx, piece, position) {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 0.05;
        
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // Desenha o contorno do bloco
                        ctx.strokeRect(x + position.x, y + position.y, 1, 1);
        
                        // Adiciona uma marca X dentro do bloco
                        ctx.beginPath();
                        ctx.moveTo(x + position.x, y + position.y);
                        ctx.lineTo(x + position.x + 1, y + position.y + 1);
                        ctx.moveTo(x + position.x + 1, y + position.y);
                        ctx.lineTo(x + position.x, y + position.y + 1);
                        ctx.stroke();
                    }
                });
            });
        }
        
        // Função para desenhar a próxima peça
        function drawNextPiece() {
            // Limpa o canvas da próxima peça
            nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        
            // Desenha grade de fundo
            nextContext.strokeStyle = '#cccccc';
            nextContext.lineWidth = 0.02;
            for (let i = 0; i <= 4; i++) {
                nextContext.beginPath();
                nextContext.moveTo(0, i);
                nextContext.lineTo(4, i);
                nextContext.stroke();
        
                nextContext.beginPath();
                nextContext.moveTo(i, 0);
                nextContext.lineTo(i, 4);
                nextContext.stroke();
            }
        
            if (player.nextPiece) {
                // Calcula posição centralizada
                const position = {
                    x: (4 - player.nextPiece.shape[0].length) / 2,
                    y: (4 - player.nextPiece.shape.length) / 2
                };
                drawPiece(nextContext, player.nextPiece, position);
            }
        }
        
        // Função para obter uma peça aleatória
        function getRandomPiece() {
            const pieceIndex = Math.floor(Math.random() * PIECES.length);
            return JSON.parse(JSON.stringify(PIECES[pieceIndex])); // Deep copy para evitar modificação no original
        }
        
        // Reset do player com uma nova peça
        function playerReset() {
            // Se já tiver uma próxima peça, usa ela
            if (player.nextPiece) {
                player.piece = player.nextPiece;
            } else {
                // Caso contrário, obtém uma nova peça aleatória
                player.piece = getRandomPiece();
            }
        
            // Gera a próxima peça
            player.nextPiece = getRandomPiece();
        
            // Posiciona a peça no topo do tabuleiro, centralizada
            player.pos.y = 0;
            player.pos.x = Math.floor(COLS / 2) - Math.floor(player.piece.shape[0].length / 2);
        
            // Verificar se a posição inicial já está ocupada (Game Over)
            if (checkCollision()) {
                gameOver = true;
                document.getElementById('game-over').style.display = 'block';
            }
        }
        
        // Função para verificar colisões
        function checkCollision() {
            const piece = player.piece.shape;
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] !== 0 &&
                        // Verificar se está dentro dos limites do tabuleiro
                        (board[y + player.pos.y] === undefined ||
                            board[y + player.pos.y][x + player.pos.x] === undefined ||
                            // Verificar se a posição já está ocupada no tabuleiro
                            board[y + player.pos.y][x + player.pos.x] !== 0)) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Função para mover a peça
        function playerMove(dir) {
            player.pos.x += dir;
            // Se houver colisão, volta à posição anterior
            if (checkCollision()) {
                player.pos.x -= dir;
            }
        }
        
        // Função para fazer a peça descer
        function playerDrop() {
            player.pos.y++;
        
            // Se houver colisão, volta à posição anterior e fixa a peça no tabuleiro
            if (checkCollision()) {
                player.pos.y--;
                mergePiece();
                playerReset();
                clearLines();
            }
        
            // Reset do contador para evitar descida dupla rápida
            dropCounter = 0;
        }
        
        // Função para fixar a peça no tabuleiro quando ela parar de cair
        function mergePiece() {
            player.piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        board[y + player.pos.y][x + player.pos.x] = 1; // Sempre usa 1 como valor
                    }
                });
            });
        }
        
        // Função para queda rápida (hard drop)
        function playerHardDrop() {
            while (!checkCollision()) {
                player.pos.y++;
            }
            player.pos.y--;
            mergePiece();
            playerReset();
            clearLines();
            dropCounter = 0;
        }
        
        // Função para rotacionar a peça
        function playerRotate(dir) {
            // Armazena a posição original para caso seja necessário desfazer a rotação
            const originalX = player.pos.x;
        
            // Realiza a rotação da matriz
            rotatePiece(dir);
        
            // Ajusta a posição se houver colisão após a rotação
            let offset = 1;
            while (checkCollision()) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
        
                // Se o offset ficar muito grande, desfaz a rotação
                if (offset > player.piece.shape[0].length) {
                    rotatePiece(-dir);
                    player.pos.x = originalX;
                    return;
                }
            }
        }
        
        // Função auxiliar para rotacionar a matriz da peça
        function rotatePiece(dir) {
            // Transposição da matriz
            for (let y = 0; y < player.piece.shape.length; y++) {
                for (let x = 0; x < y; x++) {
                    [
                        player.piece.shape[x][y],
                        player.piece.shape[y][x]
                    ] = [
                            player.piece.shape[y][x],
                            player.piece.shape[x][y]
                        ];
                }
            }
        
            // Espelhar linhas ou colunas dependendo da direção
            if (dir > 0) {
                // Horário: espelhar linhas
                player.piece.shape.forEach(row => row.reverse());
            } else {
                // Anti-horário: espelhar colunas
                player.piece.shape.reverse();
            }
        }
        
        // Função para verificar e limpar linhas completas
        function clearLines() {
            let linesCleared = 0;
        
            // Verificar linhas completas de baixo para cima
            outer: for (let y = ROWS - 1; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x] === 0) {
                        continue outer; // Se encontrar um espaço vazio, vai para a próxima linha
                    }
                }
        
                // Se chegou aqui, a linha está completa
                // Remove a linha movendo todas as linhas acima para baixo
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row); // Adiciona uma nova linha vazia no topo
                y++; // Incrementa y para verificar a mesma posição com a nova linha
        
                linesCleared++;
            }
        
            // Atualiza a pontuação baseada no número de linhas limpas
            if (linesCleared > 0) {
                // Sistema de pontuação clássico do Tetris (Nintendo)
                // 1 linha = 40 pontos, 2 linhas = 100 pontos, 3 linhas = 300 pontos, 4 linhas (Tetris) = 1200 pontos
                const points = [0, 40, 100, 300, 1200];
                score += points[linesCleared];
        
                // Aumenta a velocidade conforme a pontuação aumenta
                dropInterval = Math.max(100, 1000 - (score / 50));
            }
        }
        
        // Função para pausar/retomar o jogo
        function togglePause() {
            paused = !paused;
            if (paused) {
                // Exibir mensagem de pausa
                context.fillStyle = 'rgba(0, 0, 0, 0.1)';
                context.fillRect(0, 0, COLS, ROWS);
        
                context.font = '1px Arial';
                context.fillStyle = '#f9bc60';
                context.textAlign = 'center';
                context.fillText('PAUSADO', COLS / 2, ROWS / 2);
                context.textAlign = 'left';
            }
        }
        
        // Função para reiniciar o jogo
        function resetGame() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            dropInterval = 1000;
            gameOver = false;
            document.getElementById('game-over').style.display = 'none';
            playerReset();
        }
        
        // Configuração dos controles de teclado
        document.addEventListener('keydown', event => {
            if (gameOver && event.keyCode !== 82) return; // Apenas tecla R funciona no game over
        
            switch (event.keyCode) {
                case 65: // a
                    if (!paused) playerMove(-1);
                    break;
                case 68: // d
                    if (!paused) playerMove(1);
                    break;
                case 83: // s
                    if (!paused) playerDrop();
                    break;
                case 87: // w (Rotação)
                    if (!paused) playerRotate(1);
                    break;
                case 32: // Espaço (Hard Drop)
                    if (!paused) playerHardDrop();
                    break;
                case 13: // enter (Pause)
        
                    togglePause();
                    break;
                case 82: // R (Reset)
                    resetGame();
                    break;
            }
        });
        
        // Inicialização do jogo
        function init() {
            playerReset(); // Inicializa com a primeira peça
            update(); // Inicia o loop do jogo
        }
        
        // Aguardar carregamento do DOM antes de iniciar
        document.addEventListener('DOMContentLoaded', () => {
            init();
        });
        
        
</script>
</html>
