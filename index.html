<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <link rel="icon" href="/tetris_app_regular_icon_203201.ico">
    <title>Block Box</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!--<h1>Block Box </h1> -->
    
    <div class="game-container">
        <canvas id="tetris"></canvas>
        
        <div class="info-panel">
            <div class="score">
                Pontuação: <span id="score">0</span>
            </div>
            
            <div class="next-piece">
                <p>Próxima peça:</p>
                <canvas id="next" width="120" height="120"></canvas>
            </div>
            
            <div class="controls">
                <p>A D : Mover</p>
                <p>W : Rotacionar</p>
                <p>S : Descer</p>
                <p>Espaço : Queda rápida</p>
                <p>Enter : Pausar/Retomar</p>
                <p>R : Reiniciar</p>
            </div>
        </div>
    </div>
    
    <div id="game-over">GAME OVER</div>

    <div id="controls-touch">
        <button id="descer"><svg fill="#000000" width="20px" height="20px" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" id="arrow">
            <path d="M8.29289 2.29289C8.68342 1.90237 9.31658 1.90237 9.70711 2.29289L14.2071 6.79289C14.5976 7.18342 14.5976 7.81658 14.2071 8.20711L9.70711 12.7071C9.31658 13.0976 8.68342 13.0976 8.29289 12.7071C7.90237 12.3166 7.90237 11.6834 8.29289 11.2929L11 8.5H1.5C0.947715 8.5 0.5 8.05228 0.5 7.5C0.5 6.94772 0.947715 6.5 1.5 6.5H11L8.29289 3.70711C7.90237 3.31658 7.90237 2.68342 8.29289 2.29289Z"/>
          </svg>
        </button>

        <button id="rotacionar"><svg fill="#000000" width="20px" height="20px" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" id="arrow">
            <path d="M8.29289 2.29289C8.68342 1.90237 9.31658 1.90237 9.70711 2.29289L14.2071 6.79289C14.5976 7.18342 14.5976 7.81658 14.2071 8.20711L9.70711 12.7071C9.31658 13.0976 8.68342 13.0976 8.29289 12.7071C7.90237 12.3166 7.90237 11.6834 8.29289 11.2929L11 8.5H1.5C0.947715 8.5 0.5 8.05228 0.5 7.5C0.5 6.94772 0.947715 6.5 1.5 6.5H11L8.29289 3.70711C7.90237 3.31658 7.90237 2.68342 8.29289 2.29289Z"/>
          </svg>
        </button>

        <button id="esquerda"><svg fill="#000000" width="20px" height="20px" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" id="arrow">
            <path d="M8.29289 2.29289C8.68342 1.90237 9.31658 1.90237 9.70711 2.29289L14.2071 6.79289C14.5976 7.18342 14.5976 7.81658 14.2071 8.20711L9.70711 12.7071C9.31658 13.0976 8.68342 13.0976 8.29289 12.7071C7.90237 12.3166 7.90237 11.6834 8.29289 11.2929L11 8.5H1.5C0.947715 8.5 0.5 8.05228 0.5 7.5C0.5 6.94772 0.947715 6.5 1.5 6.5H11L8.29289 3.70711C7.90237 3.31658 7.90237 2.68342 8.29289 2.29289Z"/>
          </svg>
        </button>

        <button id="direita"><svg fill="#000000" width="20px" height="20px" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" id="arrow">
            <path d="M8.29289 2.29289C8.68342 1.90237 9.31658 1.90237 9.70711 2.29289L14.2071 6.79289C14.5976 7.18342 14.5976 7.81658 14.2071 8.20711L9.70711 12.7071C9.31658 13.0976 8.68342 13.0976 8.29289 12.7071C7.90237 12.3166 7.90237 11.6834 8.29289 11.2929L11 8.5H1.5C0.947715 8.5 0.5 8.05228 0.5 7.5C0.5 6.94772 0.947715 6.5 1.5 6.5H11L8.29289 3.70711C7.90237 3.31658 7.90237 2.68342 8.29289 2.29289Z"/>
          </svg>
        </button>

        <button id="pause"><svg fill="#000000" width="20px" height="20px" viewBox="0 0 56 56" xmlns="http://www.w3.org/2000/svg">
            <path d="M 34.5434 44.7332 L 39.0240 44.7332 C 40.7611 44.7332 41.6691 43.8252 41.6691 42.0881 L 41.6691 15.2034 C 41.6691 13.4072 40.7611 12.5782 39.0240 12.5782 L 34.5434 12.5782 C 32.8064 12.5782 31.9181 13.4862 31.9181 15.2034 L 31.9181 42.0881 C 31.9181 43.8252 32.8064 44.7332 34.5434 44.7332 Z M 48.8936 44.7332 L 53.3744 44.7332 C 55.1114 44.7332 56 43.8252 56 42.0881 L 56 15.2034 C 56 13.4072 55.1114 12.5782 53.3744 12.5782 L 48.8936 12.5782 C 47.1569 12.5782 46.2485 13.4862 46.2485 15.2034 L 46.2485 42.0881 C 46.2485 43.8252 47.1569 44.7332 48.8936 44.7332 Z M 2.8424 44.1410 C 3.6517 44.1410 4.3228 43.8844 5.1124 43.4106 L 25.2266 31.5869 C 26.6280 30.7579 27.2400 29.7709 27.2400 28.6458 C 27.2400 27.5009 26.6280 26.5337 25.2266 25.7047 L 5.1124 13.8612 C 4.3031 13.3875 3.6517 13.1309 2.8424 13.1309 C 1.3028 13.1309 0 14.3152 0 16.5260 L 0 40.7656 C 0 42.9764 1.3028 44.1410 2.8424 44.1410 Z"/>
          </svg>
        </button>

        <button id="reiniciar"><svg fill="#000000" width="20px" height="20px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4,12a1,1,0,0,1-2,0A9.983,9.983,0,0,1,18.242,4.206V2.758a1,1,0,1,1,2,0v4a1,1,0,0,1-1,1h-4a1,1,0,0,1,0-2h1.743A7.986,7.986,0,0,0,4,12Zm17-1a1,1,0,0,0-1,1A7.986,7.986,0,0,1,7.015,18.242H8.757a1,1,0,1,0,0-2h-4a1,1,0,0,0-1,1v4a1,1,0,0,0,2,0V19.794A9.984,9.984,0,0,0,22,12,1,1,0,0,0,21,11Z"/>
        </svg>
        </button>

    </div>

</body>

<script>// Configuração inicial do jogo
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nextContext = nextCanvas.getContext('2d');

// Definindo tamanho da grade do jogo
const ROWS = 20;
const COLS = 10;
const BLOCK_SIZE = 30;

// Ajustando tamanho do canvas baseado no tamanho da grade
canvas.width = COLS * BLOCK_SIZE;
canvas.height = ROWS * BLOCK_SIZE;
context.scale(BLOCK_SIZE, BLOCK_SIZE);

// Configuração do canvas para próxima peça
nextCanvas.width = 120;
nextCanvas.height = 120;
nextContext.scale(30, 30);

// Matriz que representa o tabuleiro do jogo
// 0 representa espaço vazio, 1 representa bloco ocupado
let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

// Variáveis para controle do jogo
let gameOver = false;
let paused = false;
let score = 0;
let dropCounter = 0;
let dropInterval = 1000; // Tempo em ms para peça cair um bloco
let lastTime = 0;

// Definição das peças (Tetrominós) - todas usam o mesmo valor (1) para marcar blocos
const PIECES = [
    {
        shape: [
            [0, 0, 0, 0],
            [1, 1, 1, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
        ]
    },
    {
        shape: [
            [0, 0, 1],
            [1, 1, 1],
            [0, 0, 0]
        ]
    },
    {
        shape: [
            [1, 0, 0],
            [1, 1, 1],
            [0, 0, 0]
        ]
    },
    {
        shape: [
            [1, 1],
            [1, 1]
        ]
    },
    {
        shape: [
            [1, 1, 0],
            [0, 1, 1],
            [0, 0, 0]
        ]
    },
    {
        shape: [
            [0, 1, 1],
            [1, 1, 0],
            [0, 0, 0]
        ]
    },
    {
        shape: [
            [0, 1, 0],
            [1, 1, 1],
            [0, 0, 0]
        ]
    }
];
const player = {
    pos: { x: 0, y: 0 },
    piece: null,
    nextPiece: null
};
function update(time = 0) {
    if (paused || gameOver) {
        requestAnimationFrame(update);
        return;
    }
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
        playerDrop();
        dropCounter = 0;
    }
    draw();
    requestAnimationFrame(update);
}
function draw() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    drawBoard();

    if (player.piece) {
        drawPiece(context, player.piece, player.pos);
    }
    drawNextPiece();
    document.getElementById('score').textContent = score;
    if (gameOver) {
        document.getElementById('game-over').style.display = 'block';
    }
}
function drawGrid() {
    context.strokeStyle = '#cccccc';
    context.lineWidth = 0.02;

    for (let y = 0; y <= ROWS; y++) {
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(COLS, y);
        context.stroke();
    }
    for (let x = 0; x <= COLS; x++) {
        context.beginPath();
        context.moveTo(x, 0);
        context.lineTo(x, ROWS);
        context.stroke();
    }
}
function drawBoard() {
    board.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                
                context.strokeStyle = 'white';
                context.lineWidth = 0.05;
                context.strokeRect(x, y, 1, 1);
                context.beginPath();
                context.moveTo(x, y);
                context.lineTo(x + 1, y + 1);
                context.moveTo(x + 1, y);
                context.lineTo(x, y + 1);
                context.stroke();
            }
        });
    });
}
// Função para desenhar uma peça
function drawPiece(ctx, piece, position) {
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 0.05;

    piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
        
                ctx.strokeRect(x + position.x, y + position.y, 1, 1);
                ctx.beginPath();
                ctx.moveTo(x + position.x, y + position.y);
                ctx.lineTo(x + position.x + 1, y + position.y + 1);
                ctx.moveTo(x + position.x + 1, y + position.y);
                ctx.lineTo(x + position.x, y + position.y + 1);
                ctx.stroke();
            }
        });
    });
}
function drawNextPiece() {
    nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    nextContext.strokeStyle = '#cccccc';
    nextContext.lineWidth = 0.02;
    for (let i = 0; i <= 4; i++) {
        nextContext.beginPath();
        nextContext.moveTo(0, i);
        nextContext.lineTo(4, i);
        nextContext.stroke();
        nextContext.beginPath();
        nextContext.moveTo(i, 0);
        nextContext.lineTo(i, 4);
        nextContext.stroke();
    }

    if (player.nextPiece) {
        const position = {
            x: (4 - player.nextPiece.shape[0].length) / 2,
            y: (4 - player.nextPiece.shape.length) / 2
        };
        drawPiece(nextContext, player.nextPiece, position);
    }
}
function getRandomPiece() {
    const pieceIndex = Math.floor(Math.random() * PIECES.length);
    return JSON.parse(JSON.stringify(PIECES[pieceIndex])); 
}
function playerReset() {
    
    if (player.nextPiece) {
        player.piece = player.nextPiece;
    } else {
        player.piece = getRandomPiece();
    }
    player.nextPiece = getRandomPiece();
    player.pos.y = 0;
    player.pos.x = Math.floor(COLS / 2) - Math.floor(player.piece.shape[0].length / 2);

    if (checkCollision()) {
        gameOver = true;
        document.getElementById('game-over').style.display = 'block';
    }
}
// Função para verificar colisões
function checkCollision() {
    const piece = player.piece.shape;
    for (let y = 0; y < piece.length; y++) {
        for (let x = 0; x < piece[y].length; x++) {
            if (piece[y][x] !== 0 &&           
                (board[y + player.pos.y] === undefined ||
                    board[y + player.pos.y][x + player.pos.x] === undefined ||
                    board[y + player.pos.y][x + player.pos.x] !== 0)) {
                return true;
            }
        }
    }
    return false;
}
// Função para mover a peça
function playerMove(dir) {
    player.pos.x += dir;

    if (checkCollision()) {
        player.pos.x -= dir;
    }
}
// Função para fazer a peça descer
function playerDrop() {
    player.pos.y++;

    if (checkCollision()) {
        player.pos.y--;
        mergePiece();
        playerReset();
        clearLines();
    }
    dropCounter = 0;
}
// Função para fixar a peça no tabuleiro quando ela parar de cair
function mergePiece() {
    player.piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                board[y + player.pos.y][x + player.pos.x] = 1; // Sempre usa 1 como valor
            }
        });
    });
}
// (hard drop)
function playerHardDrop() {
    while (!checkCollision()) {
        player.pos.y++;
    }
    player.pos.y--;
    mergePiece();
    playerReset();
    clearLines();
    dropCounter = 0;
}
// Função para rotacionar a peça
function playerRotate(dir) {
    const originalX = player.pos.x;
    rotatePiece(dir);
    let offset = 1;
    while (checkCollision()) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));

        if (offset > player.piece.shape[0].length) {
            rotatePiece(-dir);
            player.pos.x = originalX;
            return;
        }
    }
}
// Função auxiliar para rotacionar a matriz da peça
function rotatePiece(dir) {
    // Transposição da matriz
    for (let y = 0; y < player.piece.shape.length; y++) {
        for (let x = 0; x < y; x++) {
            [
                player.piece.shape[x][y],
                player.piece.shape[y][x]
            ] = [
                    player.piece.shape[y][x],
                    player.piece.shape[x][y]
                ];
        }
    }

    if (dir > 0) {
        player.piece.shape.forEach(row => row.reverse());
    } else {
        player.piece.shape.reverse();
    }
}
// Função para verificar e limpar linhas completas
function clearLines() {
    let linesCleared = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
            if (board[y][x] === 0) {
                continue outer; 
            }
        }
        const row = board.splice(y, 1)[0].fill(0);
        board.unshift(row); 
        y++; 
        linesCleared++;
    }
    if (linesCleared > 0) {
        // Sistema de pontuação clássico do Tetris (Nintendo)
        // 1 linha = 40 pontos, 2 linhas = 100 pontos, 3 linhas = 300 pontos, 4 linhas (Tetris) = 1200 pontos
        const points = [0, 40, 100, 300, 1200];
        score += points[linesCleared];
        // Aumenta a velocidade conforme a pontuação aumenta
        dropInterval = Math.max(100, 1000 - (score / 50));
    }
}

function togglePause() {
    paused = !paused;
    if (paused) {
        context.fillStyle = 'rgba(0, 0, 0, 0.1)';
        context.fillRect(0, 0, COLS, ROWS);
        context.font = '1px Arial';
        context.fillStyle = '#f9bc60';
        context.textAlign = 'center';
        context.fillText('PAUSADO', COLS / 2, ROWS / 2);
        context.textAlign = 'left';
    }
}
function resetGame() {
    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    score = 0;
    dropInterval = 1000;
    gameOver = false;
    document.getElementById('game-over').style.display = 'none';
    playerReset();
}
// Configuração dos controles de teclado
document.addEventListener('keydown', event => {
    if (gameOver && event.keyCode !== 82) 
    if (gameOver && 'click' !== reiniciar) 
    return; 

    switch (event.keyCode) {
        case 65: 
            if (!paused) playerMove(-1);
            break;
        case 68: 
            if (!paused) playerMove(1);
            break;
        case 83: 
            if (!paused) playerDrop();
            break;
        case 87: 
            if (!paused) playerRotate(1);
            break;
        case 32: 
            if (!paused) playerHardDrop();
            break;
        case 13: 
            togglePause();
            break;
        case 82: 
            resetGame();
            break;
    }
});
// Configuração dos botões na tela
document.getElementById('esquerda').addEventListener('click', function() {
    if (!paused && !gameOver) playerMove(-1);
});

document.getElementById('direita').addEventListener('click', function() {
    if (!paused && !gameOver) playerMove(1);
});

document.getElementById('descer').addEventListener('click', function() {
    if (!paused && !gameOver) playerDrop();
});

document.getElementById('rotacionar').addEventListener('click', function() {
    if (!paused && !gameOver) playerRotate(1);
});

document.getElementById('pause').addEventListener('click', function() {
    togglePause();
});

document.getElementById('reiniciar').addEventListener('click', function() {
    resetGame();
});

// Inicialização do jogo
function init() {
    playerReset(); // Inicializa com a primeira peça
    update(); // Inicia o loop do jogo
}
// Aguardar carregamento do DOM antes de iniciar
document.addEventListener('DOMContentLoaded', () => {
    init();
});

</script>
</html>
